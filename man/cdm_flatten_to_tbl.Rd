% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flatten.R
\name{cdm_flatten_to_tbl}
\alias{cdm_flatten_to_tbl}
\title{Flatten part of a \code{dm} into a wide table}
\usage{
cdm_flatten_to_tbl(dm, start, ..., join = left_join)
}
\arguments{
\item{dm}{A \code{\link{dm}} object}

\item{start}{Table to start from. From this table all outgoing foreign key relations are
considered to establish a processing order for the joins. An interesting choice could be
for example a fact table in a star schema.}

\item{...}{Unquoted table names to include in addition to \code{start}. If empty, all tables that can
be reached are included.}

\item{join}{The type of join to be performed, see \code{\link[dplyr:join]{dplyr::join()}}}
}
\value{
A wide table resulting of consecutively joining all tables involved to table \code{start}.
}
\description{
Gather all information of interest in one place in a wide table (on a database-\code{\link{dm}} a
temporary table will be created).
If referential integrity is given among the tables of the data model, the resulting
table of this function will contain as many rows as the table \code{start} does (exceptions are
\code{join = anti_join} (result is empty table with same columns as \code{start}) and \code{join = right_join} (
number of rows equal to those of the join-partner of \code{start})).
For more information please refer to \code{vignette("dm-joining")}.
}
\details{
With the \code{...} left empty, this function joins all the tables of your \code{\link{dm}}
object together, that can be reached from table \code{start} in the direction of the foreign
key relations (pointing from child table to parent table), using the foreign key relations to
determine the parameter \code{by} for the necessary joins.
The result is one table with unique column names.
Use the \code{...} if you want to control which tables should be joined to table \code{start}.

\strong{How does filtering affect the result?}

\emph{Case 1}, either no filter conditions are set in the \code{dm}, or only in a part unconnected to
table \code{start}:
The necessary disambiguations of the column names are performed first. Then all
involved foreign tables are joined to table \code{start} successively with the join function given in
parameter \code{join}.

\emph{Case 2}, filter conditions are set for at least one table connected to \code{start}:
The result of filtering a \code{dm} object is necessarily a data model conforming to referential integrity.
Consequently, there is no difference between \code{left_join}, \code{right_join}, \code{inner_join} and \code{full_join}.
In this case, \code{left_join} is being used. Using \code{semi_join} in \code{cdm_flatten_to_tbl()} on a filtered \code{dm}
is identical to \code{tbl(dm, start)}, and \code{anti_join} is identical to \code{tbl(dm, start) \%>\% filter(1 == 0)}.
Disambiguation is performed initially if necessary.

\strong{join-methods: \code{join = semi_join()} and \code{join = anti_join()}}

The implementation of this function for \code{semi_join} and \code{anti_join} is different from the other join-methods:
\enumerate{
\item \code{dplyr::semi_join()} is successively used to determine which rows of table \code{start} contain valid lookup-values
in the primary key columns of all its included parent tables.
\item For method \code{join = semi_join}, this is the result of the flattening. For method \code{join = anti_join},
\code{dplyr::anti_join()} is calculated between the original table and the result from 1., effectively letting
those rows of table \code{start} remain, whose references are missing in at least one parent table.
}

The result for \code{semi_join} lets you know which references are intact everywhere.
The result from \code{anti_join} tells you, which references are missing somewhere.

\strong{join-method: \code{join = right_join()}}

Mind, that calling \code{cdm_flatten_to_tbl()} on an unfiltered \code{dm} with \code{join = right_join} would not lead
to a well-defined result, if two or more foreign tables are to be joined to \code{start}. The resulting
table would depend on the order the tables are listed in the \code{dm}. Therefore trying this results
in an error.
}
\examples{
cdm_nycflights13() \%>\%
  cdm_select_tbl(-weather) \%>\%
  cdm_flatten_to_tbl(flights)
}
\seealso{
Other flattening functions: \code{\link{cdm_join_to_tbl}}
}
\concept{flattening functions}
