% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter-dm.R
\name{dm_filter}
\alias{dm_filter}
\alias{dm_apply_filters}
\title{Filtering a \code{\link{dm}} object}
\usage{
dm_filter(dm, table, ...)

dm_apply_filters(dm)
}
\arguments{
\item{dm}{A \code{dm} object.}

\item{table}{A table in the \code{dm}}

\item{...}{Logical predicates defined in terms of the variables in \code{.data}, passed on to \code{\link[dplyr:filter]{dplyr::filter()}}.
Multiple conditions are combined with \code{&} or \code{,}. Only rows where the condition evaluates
to TRUE are kept.

The arguments in ... are automatically quoted and evaluated in the context of
the data frame. They support unquoting and splicing. See \code{vignette("programming", package = "dplyr")}
for an introduction to these concepts.}
}
\description{
Filtering one table of a \code{\link{dm}} object may affect all tables connected to this table
via one or more steps of foreign key relations. Firstly, one or more filter conditions for
one or more tables can be defined using \code{dm_filter()}, with a syntax similar to \code{dplyr::filter()}.
These conditions will be stored in the \code{\link{dm}} and not immediately executed. With \code{dm_apply_filters()}
all tables will be updated according to the filter conditions and the foreign key relations.
}
\details{
\code{dm_filter()} allows you to set one or more filter conditions for one table
of a \code{\link{dm}} object. These conditions will be stored in the \code{\link{dm}} for when they are needed.
The conditions are only evaluated in one of the following scenarios:
\enumerate{
\item Calling \code{dm_apply_filters()} or \code{compute()} (method for \code{dm} objects) on a \code{dm}: each filtered table potentially
reduces the rows of all other tables connected to it by foreign key relations (cascading effect), only leaving the rows
with the corresponding key values.
Tables that are not connected to any table with an active filter are left unchanged.
This results in a new \code{dm} class object.
\item Calling one of \code{tbl()}, \code{[[.dm()}, \code{$.dm()}: the remaining rows of the requested table are calculated based on the
filter conditions and the foreign key conditions (similar to 1. but only for one table)
}

Several functions of the {dm} package will throw an error if unevaluated filter conditions exist when they are called.
}
\examples{
library(dplyr)

dm_nyc_filtered <-
  dm_nycflights13() \%>\%
  dm_filter(airports, name == "John F Kennedy Intl")

tbl(dm_nyc_filtered, "flights")
dm_nyc_filtered[["planes"]]
dm_nyc_filtered$airlines

dm_nycflights13() \%>\%
  dm_filter(airports, name == "John F Kennedy Intl") \%>\%
  dm_apply_filters()

# If you want to only keep those rows in the parent tables
# whose primary key values appear as foreign key values in
# `flights`, you can set a `TRUE` filter in `flights`:
dm_nycflights13() \%>\%
  dm_filter(flights, 1 == 1) \%>\%
  dm_apply_filters() \%>\%
  dm_nrow()
# note, that in this example the only affected table is
# `airports` (since the departure airports in `flights` are
# only the 3 NYC ones).

dm_nycflights13() \%>\%
  dm_filter(flights, month == 3) \%>\%
  dm_apply_filters()

library(dplyr)
dm_nycflights13() \%>\%
  dm_filter(planes, engine \%in\% c("Reciprocating", "4 Cycle")) \%>\%
  compute()
}
